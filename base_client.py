class IntegrityError(RuntimeError):
    """Error to raise whenever an integrity error is encountered."""
    pass


class BaseClient(object):
    """Base class to build a file store client off of.
    """
    def __init__(self, storage_server, public_key_server, crypto_object,
                 username):
        """Initializes a new BaseClient object.
        """
        self.username = username
        self.storage_server = storage_server
        self.pks = public_key_server
        self.crypto = crypto_object
        (_rsa_key, _elg_key) = self.generate_public_key_pairs()
        self.elg_priv_key = _elg_key
        self.rsa_priv_key = _rsa_key

    def generate_public_key_pairs(self):
        """Create two asymmetric key pairs for this client; one for encryption
        and the other for signatures.
        """

        rsa_key = self.crypto._load_keyfile_rsa(self.username)
        elg_key = self.crypto._load_keyfile_elg(self.username)

        if rsa_key and elg_key:
            rsa_pub_key = rsa_key.publickey()
            elg_pub_key = elg_key.publickey()
        else:
            # First remove any files that may exist
            self.crypto._remove_keyfile(self.username)

            # generate new keys
            rsa_pub_key, rsa_key = self.crypto._gen_rsa_keypair(2048)
            self.crypto._save_keyfile_rsa(self.username, rsa_key)

            elg_pub_key, elg_key = self.crypto._gen_elg_keypair(2048)
            self.crypto._save_keyfile_elg(self.username, elg_key)

        # update key server
        self.pks.put_signature_key(self.username, rsa_pub_key)
        self.pks.put_encryption_key(self.username, elg_pub_key)

        return rsa_key, elg_key


    def upload(self, name, value):
        """Places the string `value` at `name` so that future calls to
        ``download`` for `name` return `value`.
        """
        raise NotImplementedError

    def download(self, name):
        """Returns the last value stored at `name` by the owner or anyone with
        whom it has been shared, or `None` if the file does not exist.
        """
        raise NotImplementedError

    def share(self, user, name):
        """Share a file `name` with `user`.
        """
        raise NotImplementedError

    def receive_share(self, from_username, newname, message):
        """Receive a share message generated by the `share` method of another
        client with username `from_username`.
        Once this is done, the client calling this method should now be able to
        access the shared file under the name `newname`.
        """
        raise NotImplementedError

    def revoke(self, user, name):
        """Revokes `user`'s access to the file `name`.
        """
        raise NotImplementedError
